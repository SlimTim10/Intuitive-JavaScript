<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-12-03 Fri 16:14 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Functions</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" href="highlight/styles/vs2015.css">
<script src="highlight/highlight.pack.js"></script>
<script>document.addEventListener('DOMContentLoaded', (event) => { hljs.configure({tabReplace: '    '}); document.querySelectorAll('pre.src').forEach((block) => hljs.highlightBlock(block)) })</script>
<style type="text/css">code { background: #ddd; } pre.src { white-space: pre-wrap; }</style>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">Functions</h1>
<p>
<b><a href="index.html">Home</a></b>
</p>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgc2d5ebf">1. Functions</a>
<ul>
<li><a href="#orge2a1b9a">1.1. What is a function?</a></li>
<li><a href="#orgfdd8cba">1.2. Anatomy of a function</a></li>
<li><a href="#org99bba41">1.3. Function definition vs function call</a></li>
<li><a href="#orgc3a85df">1.4. Motivation</a></li>
<li><a href="#orgdc45f6b">1.5. More Details</a></li>
</ul>
</li>
<li><a href="#orgdfd3bc9">2. Exercises</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgc2d5ebf" class="outline-2">
<h2 id="orgc2d5ebf"><span class="section-number-2">1</span> Functions</h2>
<div class="outline-text-2" id="text-1">
<p>
As you probably guessed, functions are a very important concept in functional programming. The good news is functions are not a complicated matter. In fact, the core concept of a function is quite simple; that's what makes it powerful.
</p>

<p>
Functions are everywhere in code, right from the start. We've been using node's built-in <code>console.log()</code> function to print messages. Any JavaScript interpreter you use (node or a web browser) comes with tons of built-in functions ready to use. This lesson is about creating our own functions.
</p>

<p>
One thing to keep in mind is: functions are a type of value just like the others. Recall that the possible types of values are as follows:
</p>
<ul class="org-ul">
<li>undefined</li>
<li>null</li>
<li>number</li>
<li>boolean</li>
<li>function</li>
<li>string</li>
<li>array</li>
<li>object</li>
</ul>

<p>
This means we can set a variable to be equal to a function, just like any other value. What makes functions different from the other types is their ability to perform some action and return a result.
</p>
</div>

<div id="outline-container-orge2a1b9a" class="outline-3">
<h3 id="orge2a1b9a"><span class="section-number-3">1.1</span> What is a function?</h3>
<div class="outline-text-3" id="text-1-1">
<p>
A function takes things in (called <b>arguments</b>) and <b>returns</b> something. When we define a function, we need to say how many things it takes in and what it returns. The thing it returns doesn't necessarily need to make use of the things it takes in. Unlike the other types of values, functions have a particular way of being used: they're meant to <i>do</i> something. When we want a function to do its action and return a value, we need to <b>call</b> (or "run") the function. Calling a function makes the code inside the function run until it reaches a <code>return</code> statement (or the end of the function) and returns the value to the place where the function was called.
</p>

<p>
The arguments that a function takes in can be any type of value (including functions) and the thing that a function returns can also be any type of value (it can even return a function).
</p>
</div>
</div>

<div id="outline-container-orgfdd8cba" class="outline-3">
<h3 id="orgfdd8cba"><span class="section-number-3">1.2</span> Anatomy of a function</h3>
<div class="outline-text-3" id="text-1-2">
<div class="org-src-container">
<pre class="src src-js">const f = (a, b) =&gt; {
  return a + b;
};
</pre>
</div>

<ul class="org-ul">
<li>The above code defines a variable named <code>f</code> and assigns its value to be a function.</li>
<li>The <code>(a, b)</code> part means the function accepts two <b>arguments</b> when we <b>call</b> it, and they will be referred to as <code>a</code> and <code>b</code> inside the scope of the <b>function body</b> (between the curly brackets). <b>Arguments are variables</b> that a function uses when it is called. Functions can have any number of arguments, most commonly between 0-4.</li>
<li>The arrow <code>=&gt;</code> comes after the list of arguments and the curly brackets <code>{ }</code> denote the function body.</li>
<li>In the function body, the <code>return</code> statement says what value is returned when the function is called; in this case, the result of adding the two given arguments, <code>a</code> and <code>b</code>. Functions often have a lot more code in their bodies.</li>
</ul>

<p>
To make use of this function, we need to <b>call</b> it. The syntax for calling a function is writing the function's name directly followed by round brackets with values inside, something like: <code>f(1, 2)</code>. The values we put inside the round brackets are given as the arguments to the function, so we should put as many values as the function has arguments (two in the above example). We could call the above function like so:
</p>

<div class="org-src-container">
<pre class="src src-js">const three = f(1, 2); // store the function's result of 1 + 2 in a variable
console.log(three); // 3
</pre>
</div>

<p>
In the above code, the function is being called on the right side of the equals sign: <code>f(1, 2)</code>. We are calling the function <code>f</code> and passing it two numbers as arguments. In this instance of calling the function, <code>a</code> takes on the value <code>1</code>, and <code>b</code> takes on the value <code>2</code>. Then, the result of <code>a + b</code> gets returned to the place where the function was called, setting the variable named <code>three</code> equal to <code>3</code>.
</p>

<p>
Each time a function is called, it executes the body with the newly given values for arguments and produces a new result. In functional programming, functions don't have a memory so each time they're called is a brand new instance. That means whatever values are given as arguments when calling a function have no impact on subsequent calls to the same function. Consequently, this makes it easy to tell what a function is going to return when we call it because we don't have to worry about how the function was used on other lines, and only focus on the line we're interested in and the function itself.
</p>

<p>
Calling the function a few more times:
</p>

<div class="org-src-container">
<pre class="src src-js">const five = f(2, 3);
console.log(five); // 5

console.log(f(1, 1)); // 2

console.log(f(1, f(2, 3))); // 6
</pre>
</div>
</div>
</div>

<div id="outline-container-org99bba41" class="outline-3">
<h3 id="org99bba41"><span class="section-number-3">1.3</span> Function definition vs function call</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Because functions are values that can be called, there are two ways to use them: you can pass them as a value or you can call them. This is illustrated by the following example. Notice the subtly different syntax of <code>func</code> and <code>func()</code>:
</p>

<div class="org-src-container">
<pre class="src src-js">const func = () =&gt; {
  return 10;
};

console.log(func); // prints [Function: func]
console.log(func()); // prints the result of calling the function: 10

const x = func; // x is the same as func
const y = func(); // y is the result of calling func

console.log(x); // [Function: func]
console.log(x()); // 10
console.log(y); // 10
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc3a85df" class="outline-3">
<h3 id="orgc3a85df"><span class="section-number-3">1.4</span> Motivation</h3>
<div class="outline-text-3" id="text-1-4">
<p>
What makes functions so important is <b>reusability</b> and <b>composability</b>.
</p>
</div>

<div id="outline-container-orgfff4152" class="outline-4">
<h4 id="orgfff4152"><span class="section-number-4">1.4.1</span> Reusability</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
Let's say we have the following code for printing a greeting message to a person:
</p>

<div class="org-src-container">
<pre class="src src-js">const name = 'Alice';
console.log(name + ', what\'s up?'); // Alice, what's up?
</pre>
</div>

<p>
No problems there. What if we have more people and we want to print the same message each time?
</p>

<div class="org-src-container">
<pre class="src src-js">const name1 = 'Alice';
const name2 = 'Bob';
const name3 = 'Carol';
console.log(name1 + ', what\'s up?'); // Alice, what's up?
console.log(name2 + ', what\'s up?'); // Bob, what's up?
console.log(name3 + ', what\'s up?'); // Carol, what's up?
</pre>
</div>

<p>
This works, but now we have an obvious repeated pattern in our code. All three of the <code>console.log</code> lines look the same except for the name. What if we want to make a change to the greeting message? Let's say we want the messages to read, "(name), how's it going?" Well, we need to change the three <code>console.log</code> lines.
</p>

<div class="org-src-container">
<pre class="src src-js">const name1 = 'Alice';
const name2 = 'Bob';
const name3 = 'Carol';
console.log(name1 + ', how\'s it going?');
console.log(name2 + ', how\'s it going?');
console.log(name3 + ', how\'s it going?');
</pre>
</div>

<p>
This is unnecessarily repetitive work. The more lines we have that use the same pattern, the more code we have to update if we want to make even a small change. By making a function and using the name as an argument, we can have one piece of code to reuse and update:
</p>

<div class="org-src-container">
<pre class="src src-js">const name1 = 'Alice';
const name2 = 'Bob';
const name3 = 'Carol';

const printGreeting = name =&gt; {
  console.log(name + ', what\'s up?');
};

printGreeting(name1);
printGreeting(name2);
printGreeting(name3);
</pre>
</div>

<p>
Now, whenever we want to make a change to the messages we only need to update the single <code>console.log</code> line inside the function.
</p>
</div>
</div>

<div id="outline-container-org7ce07f8" class="outline-4">
<h4 id="org7ce07f8"><span class="section-number-4">1.4.2</span> Composability</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
Functions being composable enables us to break down problems into smaller, easier-to-solve pieces that we can put back together (compose) for the final solution.
</p>

<p>
As an example, let's look at creating a function to return the <a href="https://en.wikipedia.org/wiki/Factorial">factorial</a> of a number (e.g., 6! = 1 * 2 * 3 * 4 * 5 * 6 = 720). We will also create a function to return the "even factorial" of a number, where we only multiply even numbers (e.g., even factorial of 6 = 2 * 4 * 6 = 48). Some of the techniques in the following example have not been covered in the previous lessons, but you don't need to understand the details of each function in order to see how they are composed. Comments have been added for clarity.
</p>

<div class="org-src-container">
<pre class="src src-js">// Return a list of numbers from 1 up to n (inclusive)
const upTo = n =&gt; [...Array(n)].map((_, i) =&gt; i + 1);

// Multiply a list of numbers
const multiply = ns =&gt; ns.reduce((acc, n) =&gt; acc * n, 1);

// Return n! (from 1 up to n multiplied together)
const factorial = n =&gt; {
  const xs = upTo(n); // Get a list of numbers from 1 up to n (e.g., [1, 2, 3, 4, 5, 6])
  return multiply(xs); // Multiply the numbers together (e.g., 1 * 2 * 3 * 4 * 5 * 6)
};

// Condensed version
const factorialV2 = n =&gt; multiply(upTo(n)); // Multiply the numbers from 1 up to n

console.log(factorial(6)); // 720
console.log(factorialV2(6)); // 720

// Return true if n is even, otherwise false
const isEven = n =&gt; n % 2 === 0;

// Return the even numbers from 1 up to n multiplied together
const evenFactorial = n =&gt; {
  const xs = upTo(n); // Get a list of numbers from 1 up to n (e.g., [1, 2, 3, 4, 5, 6])
  const evens = xs.filter(isEven); // Keep only the even numbers in the list (e.g., [2, 4, 6])
  return multiply(evens); // Multiply the numbers together (e.g., 2 * 4 * 6)
};

// Condensed version
const evenFactorialV2 = n =&gt; multiply(upTo(n).filter(isEven)); // Multiply the even numbers from 1 up to n

console.log(evenFactorial(6)); // 48
console.log(evenFactorialV2(6)); // 48
</pre>
</div>

<p>
What's important to note in the code above is how small functions were made to handle small steps of the overall problem. For example, <code>upTo()</code> has the job of building a list of numbers from 1 up to the given number. This allows us to focus on small problems (make a list of numbers, multiply a list of numbers, check if a number is even), then compose them together to solve a bigger problem (factorial, even factorial). To get the factorial of a number, n, we can make a list of numbers from 1 up to n, then multiply those numbers together. This is composing <code>multiply()</code> with <code>upTo()</code>.
</p>

<p>
The condensed versions of factorial and even factorial work the same way as their uncondensed counterparts; they simply skip the steps of using intermediate variables. Either way is fine, so long as you can read and understand the code. You may find that you prefer the uncondensed versions now, and later after you gain more experience you may prefer the condensed versions.
</p>
</div>
</div>
</div>

<div id="outline-container-orgdc45f6b" class="outline-3">
<h3 id="orgdc45f6b"><span class="section-number-3">1.5</span> More Details</h3>
<div class="outline-text-3" id="text-1-5">
</div>
<div id="outline-container-org7e0f0a0" class="outline-4">
<h4 id="org7e0f0a0"><span class="section-number-4">1.5.1</span> Implicit return shortcut</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
When we want to define a short function, there's a more compact way of writing it. If we omit the curly brackets <code>{ }</code>, then the expression directly following the arrow <code>=&gt;</code> becomes the function's return value.
</p>

<div class="org-src-container">
<pre class="src src-js">const longVersion = (a, b) =&gt; {
  return a + b;
};

const shortVersion = (a, b) =&gt; a + b;
</pre>
</div>

<p>
However, this doesn't help if we want to do more things in the function body before the return.
</p>
</div>
</div>

<div id="outline-container-org90f098e" class="outline-4">
<h4 id="org90f098e"><span class="section-number-4">1.5.2</span> No return value</h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
Functions don't always need to explicitly return a result. However, if a function doesn't explicitly have a <code>return</code> statement, it will still return a value: <code>undefined</code>. In fact, <code>console.log()</code> is one such function; it doesn't return a value other than <code>undefined</code> because its job is to simply perform an action (print to the console).
</p>

<p>
An example would be something like the following function, which only prints something:
</p>

<div class="org-src-container">
<pre class="src src-js">const printMessage = () =&gt; {
  console.log('Hello, world!');
};

printMessage(); // prints "Hello, world!"

const x = printMessage();
console.log(x); // undefined
</pre>
</div>

<p>
To be clear, the <code>console.log</code> is not what this function returns. That is an action that the function is performing, along with implicitly returning <code>undefined</code>. You can imagine that the function has a hidden <code>return</code> statement inside it:
</p>

<div class="org-src-container">
<pre class="src src-js">const printMessage = () =&gt; {
  console.log('Hello, world!');
  return undefined;
};

printMessage(); // prints "Hello, world!"

const x = printMessage();
console.log(x); // undefined
</pre>
</div>
</div>
</div>

<div id="outline-container-orgaefbaa7" class="outline-4">
<h4 id="orgaefbaa7"><span class="section-number-4">1.5.3</span> Synonymous syntax</h4>
<div class="outline-text-4" id="text-1-5-3">
<p>
The following functions work exactly the same, written with different syntax.
</p>

<div class="org-src-container">
<pre class="src src-js">// Return true if b is between a and c, otherwise false
const betweenV1 = (a, b, c) =&gt; {
  if (a &lt; b &amp;&amp; b &lt; c) {
    return true;
  } else {
    return false;
  }
};
console.log(betweenV1(1, 2, 3)); // true, because 2 is between 1 and 3

const betweenV2 = (a, b, c) =&gt; {
  if (a &lt; b &amp;&amp; b &lt; c) {
    return true;
  }

  return false;
};
console.log(betweenV2(1, 2, 3)); // true

const betweenV3 = (a, b, c) =&gt; {
  return a &lt; b &amp;&amp; b &lt; c;
};
console.log(betweenV3(1, 2, 3)); // true

const betweenV4 = (a, b, c) =&gt; a &lt; b &amp;&amp; b &lt; c;
console.log(betweenV4(1, 2, 3)); // true
</pre>
</div>

<p>
The reason that <code>betweenV2()</code> works is due to the fact that when the code execution reaches a <code>return</code> statement, it returns the value and stops the rest of the function's code from executing (remember, returning a value is always the last thing a function does). So the <code>return false;</code> statement will only execute if the previous <code>return</code> was not reached, that is, when the <code>if</code> condition is false.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgdfd3bc9" class="outline-2">
<h2 id="orgdfd3bc9"><span class="section-number-2">2</span> Exercises</h2>
<div class="outline-text-2" id="text-2">
<ul>
	<li><a href="05-functions-exercises.js">View exercises</a></li>
	<li><a href="05-functions-exercises.js" download type="application/octet-stream">Download exercises</a></li>
	<li><a href="05-functions-solutions.js">View solutions</a></li>
	<li><a href="05-functions-solutions.js" download type="application/octet-stream">Download solutions</a></li>
</ul>
</div>
</div>
</div>
</body>
</html>
